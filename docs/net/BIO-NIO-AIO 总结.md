# BIO，NIO，AIO 总结

1. BIO 传统的socket编程，属于同步阻塞模型
2. NIO 官方(new io) jdk1.4推出 俗称(non-block io) ，属于同步非阻塞模式
3. AIO 又称NIO2.0在jdk1.7推出，属于异步非阻塞模式

- 同步与异步

    - 同步： 同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。

    - 异步： 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。

同步和异步的区别最大在于异步的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。

- 阻塞和非阻塞

    - 阻塞： 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。

    - 非阻塞： 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。

## BIO (Blocking I/O)

同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。

这个模式是每个连接每个线程，之所以用多线程， 主要原因是在socket.accept(),socket.read(),socket.wirte() 三个函数都是同步阻塞的， 当一个连接在处理IO的时候， 系统是阻塞的，如果是单线程的话系统必然死掉， 如果是单线程的话，对于多核cpu，cpu的资源没有得到很好的利用，所以采用线程池的模式，这样线程的创建和回收成本相对较低；

>对十万甚至百万级连接的时候，BIO有几个问题：

- 1、线程的创建和销毁成本很高，在Linux这样的操作系统中，线程本质上就是一个进程。创建和销毁都是重量级的系统函数；

- 2、线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千，恐怕整个JVM的内存都会被吃掉一半；

- 3、线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。如果线程数过高，可能执行线程切换的时间甚至会大于线程执行的时间，这时候带来的表现往往是系统load偏高、CPU sy使用率特别高（超过20%以上)，导致系统几乎陷入不可用的状态；

- 4、容易造成锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，一旦线程数量高但外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载压力过大；

在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。

## NIO模型

NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。

NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。

阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。

基础知识

>缓冲区 Buffer

在NIO中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，也是写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。
缓冲区实际上是一个数组，并提供了对数据结构化访问以及维护读写位置等信息。
具体的缓存区有这些：ByteBuffe、CharBuffer、 ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。他们实现了相同的接口：Buffer

>通道 Channel

对数据的读取和写入要通过Channel，它就像水管一样，是一个通道。通道不同于流的地方就是通道是双向的，可以用于读、写和同时读写操作。
底层的操作系统的通道一般都是全双工的，所以全双工的Channel比流能更好的映射底层操作系统的API。
Channel主要分两大类：

- SelectableChannel：用户网络读写

- FileChannel：用于文件操作

>多路复用器 Selector

Selector是Java NIO 编程的基础。
Selector提供选择已经就绪的任务的能力：Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。

一个Selector可以同时轮询多个Channel，因为JDK使用了epoll()代替传统的select实现，所以没有最大连接句柄1024/2048的限制。所以，只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。

nio解决的是非阻塞，通过selector轮询上注册的channel的状态，来获取对应准备就绪channel的 那么请求者就不用一直去accpet阻塞等待。因为请求者不停的轮询selector是否有完全就绪的channel,所以是同步的。

>工作模式

1. nio主要有几个事件，包括读就绪，写就绪， 新连接到来， 当有新事件操作时，首先把事件注册到对应的处理器；

2. 并由一个线程不断循环等待，调用操作系统底层的函数select() 或者 epoll（Linux 2.6之前是select、poll，2.6之后是epoll，Windows是iocp），并负责向操作系统查询IO是否就绪(标记：从网卡已经拷贝到内核缓存区，准备就绪)，如果就绪执行事件处理器（从内核缓存区到用户内存）；

这个过程就是利用了Reactor事件驱动的模式；

select 与 epoll的区别：

- 1、每次调用select，都要把fd_set（加入文件描述符至集合）从用户态拷贝到内核态，fd_set很大时这是费时操作

- 2、每次调用select，内核态都要遍历fd_set，fd_set很大时这是费时操作， epoll 如果准备就绪，系统回调通知，有个回调函数；

- 3、select支持的文件描述符数量太小，默认是1024， epoll没有限制（系统最大的文件句柄数）

---

NIO并没有完全屏蔽平台差异，它仍然是基于各个操作系统的I/O系统实现的，差异仍然存在。使用NIO做网络编程构建事件驱动模型并不容易，陷阱重重。

一般不用 JDK 原生 NIO 进行开发，它还有以下让人诟病的问题：

- JDK 的 NIO 底层由 epoll 实现，空轮询会导致 cpu 飙升 100%

- 项目庞大之后，自行实现的 NIO 很容易出现各类 bug，维护成本较高

Netty 的出现很大程度上改善了 JDK 原生 NIO 所存在的一些让人难以忍受的问题。

## AIO

AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

异步的套接字通道时真正的异步非阻塞I/O，对应于UNIX网络编程中的事件驱动I/O（AIO）。他不需要过多的Selector对注册的通道进行轮询即可实现异步读写，从而简化了NIO的编程模型。

AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。