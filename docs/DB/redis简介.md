## redis 简介
* Redis 是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、
Key-Value数据库

>Redis 是一个 Key-Value 存储系统。和 Memcached 类似，它支持存储的 value 类型相对更多，包括 string(字符串)、list(链表)、set(集合)和 zset(有序集合)。这些数据类型都支持 push/pop、add/remove 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis 支持各种不同方式的排序。与 memcached 一样，为了保证效率，数据都是缓存在内存中。区别的是 Redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave(主从)同步。


### Key-Value 存储系统简介

- Key-Value Store 是当下比较流行的话题，尤其在构建诸如搜索引擎、IM、P2P、游戏服务器、
SNS 等大型互联网应用以及提供云计算服务的时候，怎样保证系统在海量数据环境下的高性
能、高可靠性、高扩展性、高可用性、低成本成为所有系统架构们挖苦心思考虑的重点，而
怎样解决数据库服务器的性能瓶颈是最大的挑战。

- Key-Value Store 更加注重对海量数据存取的性能、分布式、扩展性支持上，并不需要传统关系数据库的一些特征，例如：Schema、事务、完整 SQL 查询支持等等，因此在分布式环境下的性能相对于传统的关系数据库有较大的提升。

### 数据类型
- 作为 Key-value 型数据库，Redis 也提供了键（Key）和键值（Value）的映射关系。但是，除了常规的数值或字符串，Redis 的键值还可以是以下形式之一：
    - Lists （列表）
    - Sets （集合）
    - Sorted sets （有序集合）
    - Hashes （哈希表）

键值的数据类型决定了该键值支持的操作。Redis 支持诸如列表、集合或有序集合的交集、
并集、查集等高级原子操作；同时，如果键值的类型是普通数字，Redis 则提供自增等原子
操作。

### 适用场合

#### 1、取最新 N 个数据的操作
- 比如典型的取你网站的最新文章，通过下面方式，我们可以将最新的 5000 条评论的 ID 放在
Redis 的 List 集合中，并将超出集合部分从数据库获取。
使用 `LPUSH latest.comments<ID>`命令，向 list 集合中插入数据
插入完成后再用 LTRIM latest.comments 0 5000 命令使其永远只保存最近 5000 个 ID

- 如果你还有不同的筛选维度，比如某个分类的最新 N 条，那么你可以再建一个按此分类的
List，只存 ID 的话，Redis 是非常高效的。

#### 2、排行榜应用，取 TOP N 操作
这个需求与上面需求的不同之处在于，前面操作以时间为权重，这个是以某个条件为权重，
比如按顶的次数排序，这时候就需要我们的 sorted set 出马了，将你要排序的值设置成 sorted 
set 的 score，将具体的数据设置成相应的 value，每次只需要执行一条 ZADD 命令即可。
#### 3、需要精准设定过期时间的应用
比如你可以把上面说到的 sorted set 的 score 值设置成过期时间的时间戳，那么就可以简单
地通过过期时间排序，定时清除过期数据了，不仅是清除 Redis 中的过期数据，完全可以
把 Redis 里这个过期时间当成是对数据库中数据的索引，用 Redis 来找出哪些数据需要过期
删除，然后再精准地从数据库中删除相应的记录。
#### 4、计数器应用
Redis 的命令都是原子性的，你可以轻松地利用 INCR，DECR 命令来构建计数器系统。
#### 5、Uniq 操作，获取某段时间所有数据排重值
这个使用 Redis 的 set 数据结构最合适了，只需要不断地将数据往 set 中扔就行了，set 意为
集合，所以会自动排重。
#### 6、实时系统，反垃圾系统
通过上面说到的 set 功能，你可以知道一个终端用户是否进行了某个操作，可以找到其操作
的集合并进行分析统计对比等。
#### 7、Pub/Sub 构建实时消息系统
Redis 的 Pub/Sub 系统可以构建实时的消息系统，比如很多用 Pub/Sub 构建的实时聊天系统的例子。
#### 8、构建队列系统
使用 list 可以构建队列系统，使用 sorted set 甚至可以构建有优先级的队列系统。
#### 9、缓存
与Memcached相比，数据结构更多样化。


### 配置 Redis

实例启动时会加很多的参数以便使系统运行的非常稳定，这样
就可能会在启动时在 Redis 后面加一个参数，以指定配置文件的路径，就象 mysql 一样的读
取启动配置文件的方式来启动数据库。源码编译完成后，在 redis目录下有一个
redis.conf 文件，这个文件即是 Redis 的配置文件，用配置文件来启动 Redis 的方法如下:

```
 src/redis-server redis.conf
```

- Redis 支持很多的参数，但都有默认值。
    - `daemonize`:
    默认情况下，redis 不是在后台运行的，如果需要在后台运行，把该项的值更改为 yes
    - `pidfile`:
    当 Redis 在后台运行的时候，Redis 默认会把 pid 文件放在/var/run/redis.pid，你可以配
    置到其他地址。当运行多个 redis 服务时，需要指定不同的 pid 文件和端口
    - `bind`
    指定 Redis 只接收来自于该 IP 地址的请求，如果不进行设置，那么将处理所有请求，在
    生产环境中最好设置该项
    - `port`
    监听端口，默认为 6379
    - `timeout`
    设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，
    那么关闭该连接
    - `loglevel`
    log 等级分为 4 级，debug, verbose, notice, 和 warning。生产环境下一般开启 notice
    - `logfile`
    配置 log 文件地址，默认使用标准输出，即打印在命令行终端的窗口上
    - `databases`
    设置数据库的个数，可以使用 `SELECT <dbid>`命令来切换数据库。默认使用的数据库是 0 
    - `save`
    设置 Redis 进行数据库镜像的频率。
    ```
    if(在 60 秒之内有 10000 个 keys 发生变化时){
    进行镜像备份
    }else if(在 300 秒之内有 10 个 keys 发生了变化){
    进行镜像备份
    }else if(在 900 秒之内有 1 个 keys 发生了变化){
    进行镜像备份
    } 
    ```
    - `rdbcompression`
    在进行镜像备份时，是否进行压缩
    - `dbfilename`
    镜像备份文件的文件名
    - `dir`
    数据库镜像备份的文件放置的路径。这里的路径跟文件名要分开配置是因为 Redis 在进
    行备份时，先会将当前数据库的状态写入到一个临时文件中，等备份完成时，再把该该
    临时文件替换为上面所指定的文件，而这里的临时文件和上面所配置的备份文件都会放
    在这个指定的路径当中
    - `slaveof`
    设置该数据库为其他数据库的从数据库
    - `masterauth`
    当主数据库连接需要密码验证时，在这里指定
    - `requirepass`
    设置客户端连接后进行任何其他指定前需要使用的密码。`警告`：因为 redis 速度相当快，
    所以在一台比较好的服务器下，一个外部的用户可以在一秒钟进行 150K 次的密码尝试，
    这意味着你需要指定非常非常强大的密码来防止暴力破解。
    - `maxclients`
    限制同时连接的客户数量。当连接数超过这个值时，redis 将不再接收其他连接请求，
    客户端尝试连接时将收到 error 信息。
    - `maxmemory`
    设置 redis 能够使用的最大内存。当内存满了的时候，如果还接收到 set 命令，redis 将
    先尝试剔除设置过 expire 信息的 key，而不管该 key 的过期时间还没有到达。在删除时，
    将按照过期时间进行删除，最早将要被过期的 key 将最先被删除。如果带有 expire 信息
    的 key 都删光了，那么将返回错误。这样，redis 将不再接收写请求，只接收 get 请求。
    maxmemory 的设置比较适合于把 redis 当作于类似 memcached 的缓存来使用。
    - `appendonly`
    默认情况下，redis 会在后台异步的把数据库镜像备份到磁盘，但是该备份是非常耗时
    的，而且备份也不能很频繁，如果发生诸如拉闸限电、拔插头等状况，那么将造成比较
    大范围的数据丢失。所以 redis 提供了另外一种更加高效的数据库备份及灾难恢复方式。
    开启 append only 模式之后，redis 会把所接收到的每一次写操作请求都追加到
    appendonly.aof 文件中，当 redis 重新启动时，会从该文件恢复出之前的状态。但是这样
    会造成 appendonly.aof 文件过大，所以 redis 还支持了 BGREWRITEAOF 指令，对
    appendonly.aof 进行重新整理。所以我认为推荐生产环境下的做法为关闭镜像，开启
    appendonly.aof，同时可以选择在访问较少的时间每天对 appendonly.aof 进行重写一次。
    - `appendfsync`
    设置对 appendonly.aof 文件进行同步的频率。always 表示每次有写操作都进行同步，
    everysec 表示对写操作进行累积，每秒同步一次。这个需要根据实际业务场景进行配置
    - `vm-enabled`
    是否开启虚拟内存支持。因为 redis 是一个内存数据库，而且当内存满的时候，无法接
    收新的写请求，所以在 redis 中，提供了虚拟内存的支持。但是需要注意的是，redis
    中，所有的 key 都会放在内存中，在内存不够时，只会把 value 值放入交换区。这样保
    证了虽然使用虚拟内存，但性能基本不受影响，同时，你需要注意的是你要把
    vm-max-memory 设置到足够来放下你的所有的 key
    - `vm-swap-file`
    设置虚拟内存的交换文件路径
    - `vm-max-memory`
    这里设置开启虚拟内存之后，redis 将使用的最大物理内存的大小。默认为 0，redis 将
    把他所有的能放到交换文件的都放到交换文件中，以尽量少的使用物理内存。在生产环
    境下，需要根据实际情况设置该值，最好不要使用默认的 0 
    - `vm-page-size`
    设置虚拟内存的页大小，如果你的 value 值比较大，比如说你要在 value 中放置博客、
    新闻之类的所有文章内容，就设大一点，如果要放置的都是很小的内容，那就设小一点。
    - `vm-pages`
    设置交换文件的总的 page 数量，需要注意的是，page table 信息会放在物理内存中，每
    8 个 page 就会占据 RAM 中的 1 个 byte。总的虚拟内存大小 ＝ vm-page-size * vm-pages
    - `vm-max-threads`
    设置 VM IO 同时使用的线程数量。因为在进行内存交换时，对数据有编码和解码的过
    程，所以尽管 IO 设备在硬件上本上不能支持很多的并发读写，但是还是如果你所保存
    的 vlaue 值比较大，将该值设大一些，还是能够提升性能的
    - `glueoutputbuf`
    把小的输出缓存放在一起，以便能够在一个 TCP packet 中为客户端发送多个响应，具体
    原理和真实效果我不是很清楚。所以根据注释，你不是很确定的时候就设置成 yes
    - `hash-max-zipmap-entries`
    在 redis 2.0 中引入了 hash 数据结构。当 hash 中包含超过指定元素个数并且最大的元素
    没有超过临界时，hash 将以一种特殊的编码方式（大大减少内存使用）来存储，这里
    可以设置这两个临界值
    - `activerehashing`
    开启之后，redis 将在每 100 毫秒时使用 1 毫秒的 CPU 时间来对 redis 的 hash 表进行重
    新 hash，可以降低内存的使用。当你的使用场景中，有非常严格的实时性需要，不能
    够接受 Redis 时不时的对请求有 2 毫秒的延迟的话，把这项配置为 no。如果没有这么严
    格的实时性要求，可以设置为 yes，以便能够尽可能快的释放内存

