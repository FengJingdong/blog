
## Java并发机制
---
Java代码在编译后会变成Java字节码，字节码被类加载器加载到JVM里，JVM执行字节 码，最终需要转化为汇编指令在CPU上执行


### volatile
* 轻量级的 synchronized，它在多处理器开发中保证了共享变量的“可见性”(线程修改一个共享变量时，另外一个线程能读到这个修改的值)。

* 如果volatile变量修饰符使用恰当的话，它不会引起线程上下文的切换和调度,比synchronized的使用和执行成本更低。

#### 为什么volatile能提高效率

* `共享变量不会被频繁地写`。因为使用追加字节的方式需要处理器读取更多的字节到高速 缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。

### synchronized

* 重量级锁
* 对于普通同步方法，锁是当前实例对象。
* 对于静态同步方法，锁是当前类的Class对象。
* 对于同步方法块，锁是Synchonized括号里配置的对象。

### Java SE 1.6锁的升级
p29